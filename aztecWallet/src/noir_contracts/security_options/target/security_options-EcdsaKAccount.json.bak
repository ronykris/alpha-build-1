{"noir_version":"0.33.0+eab944cbb77eb613e61a879312b58c415f8a0c13","name":"EcdsaKAccount","functions":[{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"app_payload","type":{"kind":"struct","path":"authwit::entrypoint::app::AppPayload","fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"fee_payload","type":{"kind":"struct","path":"authwit::entrypoint::fee::FeePayload","fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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mjntSac1d1oLp7V02lNOa+W01k5r47S2TmvntPZO6+C0jk7r5LTOTuvitK5O6+a07k7r4bSnndbTab2c1ttpfZzW12n9nNbfaQOcNtBpg5w22GlDnDbUacOcNtxpzzhthNNGOm2U05512minjXHaWKc957RxThvvtAlOe95pE502yWmTnTbFaVOdNs1p0532gtNmOG2m01502ktOe9lps5z2itNmO+1Vp81x2mtOm+u01502z2lvOG2+09502gKnveW0hU5b5LTFTlvitKVOW+a05U5b4bSVTlvltNVOe9tpa5z2jtPWOm2d09Y7bYPTNjptk9M2O22L07Y67V2nbXPadqftcNp7TtvptPedtstpHzhtt9M+dNoep33ktL1O+9hp+5z2idM+ddpnTtvvtM+ddsBpXzjtoNMOOe1Lpx122hGnfeW0r5121GnHnHbcad847YTTTjrtlNO+ddppp51x2lmnfee0c04777TvnfaD0y447aLTLjntR6f95LTLTrvitJ+ddtVp15z2i9N+ddp1p91w2k2n/ea0W0677bQ7TvvdaXedds9pbiEQw2kRTovptFhOi+20OE6L67R4TovvtAROS+i0RE5L7LQkTkvqtGROS+60FE5L6bRUTkvttDROS+u0dE5L77QMTsvotEeclslpmZ2WxWlep2V1WjanZXdaDqfldFoup+V2Wh6n5XVaPqfld9qjTivgtIJOK+S0wk4zTivitKJOc9/N7r5v2n1nsvsOYfeduu47Zt13rrrvIHXfyem+79J9l+Qf72l0mvt+Qffdfe578dx3zrnvc3Pflea+h8x9x5f7/iz33VTue5/cdyq57yty3wXkvmfHfe+M+04X9x0n7vtD3HdzuO+9cN8p4b6vwX0XgvueAfcZ/u7z8d1nz7vPdXefme4+j7yN09znaLvPqHaf/+w+W9l9brH7TGD3ebvus2zd58S6z2B1n2/qPjvUfS6n+8xL93mS7rMa3ecgus8YdJ/f5z4bz33unPtMN/d5ae6zyNznfLnP0HKfT+U++8l9rpL7zCL3eUCjnOY+x8Z9Roz7/BX32Sbuc0Pc2sd93oX7LAn3OQ3uMxDc5wu49+6798W795y793O790q79yG79/i698+696a6932691S69yu69wK699m597C594e591659zW59wy59+O84TT3PhL3Hg33/gf3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","debug_symbols":"7P3dciRNkibo3Usfz4Gbmar97K1QKJQld5eyIiuzFO7waGTunZ5VXyJzGqiEVE008AAaR5M97Y1P1SPzDQ0LPOr/9d/+l//1//n/+3//P/73//y//Z//17/9T/+3//pv/8f/+f/6n//L//5//uf7f/qv/zbib/9//9f/53/+zz/+x//rv/zP/9//8m//0/Wf/u1//c//y/3//rf/9G//2//+f/yv//Y/zfnf/tOry/rO8deVfa98ubhlvnH1OCf+ujqutd65ul19rr8uv/+8f5Uy2njr+nF+1tKi9V9X97cubtfPFluL8/vF//f/9G8jn/fk1T2Zz3vy6p6s5z15dU/28568uifneU/+/T2J63lPXt2T9rwnr+5Jf96TV/dkPO/Jq3sSz3vy6p4859jX9+Q5x76+J8859vU9ec6xr+/Jc459dU/yOce+vifPOfb1PXnOsa/viTvHjite7slo+717svPlFu41/4fuSTzvyat74s6xn3dPnnPs63vynGNf35PnHPv6njzn2Ff3ZD7n2Nf35DnHvr4nzzn29T15nse+vifxvCev7snzPPb1PXnOsa/vyXOOfX1PnnPs63vynGNf3ZP1nGNf35PnHPv6njzn2Nf35Hke+/qexPOevLonz/PY1/fk4+bYGNl/3pP7z3CerOc9eXVP9vOevLon53lP/v092dfznry6J429J5/2vrM/bo6NyPx5T3I0+O/JeN6TV/cknvfk1T3J5z15dU/m8568uifreU9e3ZPN3pPPey/+H5ljx5k/r7w/9P6q46wfP/pc/3E/+n9kqmp9zJ83pK/fX5t44+oT/ee9PhHxeyFv/CUZV//5ut9/zvj3dfcvWveb00k7o/0s6Pz2N+vt6jNe/orn/NXqevMfRJv50ur89eqvbiXKied9efO+5PO+vHlf5vO+vHlf1vO+vHlf9vO+vHlfzvO+vHVf7v/l88a8fWPa88a8fWP688a8fWOeM+8/uDHxvDFv35jn1PsPbsxz7P0HN+Y59/6DG/McfP/BjXlOvm/fmPacfP/BjXlOvv/gxjwn339wY56T7z+4MfG8MW/fmOfk+w9uzHPy/Qc35jn5/oMb85x8/8GNeU6+b9+Ybk++n/arDa3bk+8n3phHTL7z143Z796Y9lJ7/+1v+49fYrD+KY3njXn7xsTzxrx9Y/J5Y96+MfN5Y96+Met5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25eW7UvL9qVl+9KyfWnZvrRsX1q2Ly3bl5btS8v2pWX70rJ9adm+tGxfWrYvLduXlu1Ly/alZfvSsn1p2b60bF9ati8t25eW7UvL9qVl+9KyfWnZvrRsX1q2Ly3bl5btS8v2pWX70rJ9adm+tGxfWrYvLduXlu1Ly/alZfvSsn1p2b60bF9ati8t25eW7UvL9qVl+9KyfWnZvrRsX1q2Ly3bl5btS8v2pWX70rJ9adm+tGxfWrYvLduXlu1Ly/ZNy/ZNy/ZNy/ZNy/bNi0rladm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+adm+Zdm+Zdm+Zdm+Zdm+dVGpvCzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbtyzbty3bty3bty3bty3bty8qlbdl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl+7Zl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wF+k1TrTUtaZlrLOtJR1pqWsMy3NOtPSrDMtzTrT0qwzLT1kN/UXabXOtDTrTEuzzrQ060xLs860tOpMS6vOtETv6n5wq3WmJXpL94NbrTMt0fu5H9xqnWnpW+3yfqfVOtPSt9rl/U6rdaalOru8V51d3qvOLu9VZ5f3qrPLe9XZ5b3q7PJedXZ5rzq7vFedXd6rzi7vVWeX96qzy3vV2eW96uzyXnV2ea86u7xXnV3eu84u711nl/eus8t719nlva+o02qZaWnX2eW96+zy3nV2ee86u7x3nV3eu84u711nl/eus8t719nlvevs8t51dnnvOru8d51d3rvOLu9dZ5f3rrPLe9fZ5b3r7PLedXZ57zq7vHedXd67zi7vXWeX966zy3vX2eW96+zy3nV2ee86u7x3nV3eu84u711nl/eus8t719nlvevs8t51dnnvOru8d51d3rvOLu9dZ5f3rrPLe9fZ5b3r7PLedXZ57zq7vHedXd67zi7vXWeX966zy3vX2eW96+zy3nV2ee86u7x3nV3eu84u711nl/eus8t719nlvevs8t51dnnvOru8d51d3rvOLu9dZ5f3rrPLe9fZ5b3r7PLedXZ57zq7vHedXd67zi7vXWeX966zy3vX2eW96+zy3nV2ee86u7x3nV3eu84u711nl/eus8t719nlvevs8t51dnnvOru8d51d3rvOLu9dZ5f3rrPLe9fZ5b3r7PLedXZ57zq7vHedXd77e+3yXv2l1f3vWz3fa5f3n1v96GlprJfio80/t9ryPiX5+aNnu+L3Vv9efv/a5Q+5/Nmi/yp/ntflx9cuP792+fNrl7/k8tfVXn70umK/E7Jz/2r2nFchu+u0esq0+uE7rD+xVXpKeGyr9ETxT7b6x4n+NHr6eGyrUadVeqp5bKv0BPTYVr/TtPROq99pWnqn1e80Lf251f6dpqV3Wv1O09I7rdaZlnqdaenDd1h/Yqt1pqVeZ1rqdaalXmda6nWmpVFnWhp1pqVRZ1oadaalD99h/Ymt1pmWRp1padSZlkadaWnUmZaizrQUdaalqDMtRZ1p6cN3WH9iq3WmpagzLUWdaSnqTEtRZ1rKOtNS1pmWss60lHWmpQ/fYf2JrdaZlrLOtJR1pqWsMy1lnWlp1pmWZp1padaZlmadaenDd1h/Yqt1pqVZZ1qadaalWWdamnWm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MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDybmBxPzg4n5wcT8YF5WPifmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH5yYH5yYH5yYH5yYH5yXlc8T84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84MT84ML84ML84ML84ML84PrsvJ5YX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5wYX5w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4MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD8YGB+MDA/GJgfDMwPxmXlc2B+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcT8YGJ+MDE/mJgfzMvK58T8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzgxPzgxPzgxPzgxPzg/Oy8nlifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBhfnBhfnBhfnBhfnBdVj4vzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA8uzA9uzA9uzA9uzA9uzA/uy8rnjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBjfnBg/nBg/nBg/nBg/nBc1n5fDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/eDA/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fjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4n5wcT8YGJ+MDE/mJeVz4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmByfmByfmByfmByfmB+dl5fPE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODE/ODC/ODC/ODC/ODC/OC6rHxemB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB9cmB/cmB/cmB/cmB/cmB/cl5XPG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODG/ODB/ODB/ODB/ODB/OD57Ly+WB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8GB+8Fh+cF6WH7zrofL5rofK57seKp/veqh8vuuh8vmuh8rnux4qn+96qHy+68Hy2fKDdz1YPlt+8K4Hy2fLD971YPls+cG7HiyfLT9414Pls+UH73qwfLb84F0Pls+WH7zrwfLZ8oN3PVg+W37wrgfLZ8sP3vVg+Wz5wbseLJ8tP3jXg+Wz5QfverB8tvzgXQ+Wz5YfvOvB8tnyg3c9WD5bfvCuB8tnyw/e9WD5bPnBux4sny0/eNeD5bPlB+96sHy2/OBdD5bPlh+868Hy2fKDdz1YPlt+8K4Hy2fLD971YPls+cG7HiyfLT9414Pls+UH73qwfLb84F0Pls+WH7zrwfLZ8oN3PVg+W37wrgfLZ8sP3vVg+Wz5wbseLJ8tP3jXg+Wz5QfverB8tvzgXQ+Wz5YfvOvB8tnyg3c9WD5bfvCuB8tnyw/e9WD5bPnBux4sny0/eNdj5XPD/GDD/GDD/GDD/GC7rHxumB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB/smB/smB/smB/smB/sl5XPHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfODHfOD/aP94D0g778uvmeL8Xs9b108r+vl6jmul8vPerOQ1X8Wsna+XJx/tTrqtBp1Ws06rc46ra46rTrv4G9cPOfLxXP9qn1cP6t33u//heohvfqvVN/gfyR3f/386jXmn/+R3C9Fz58//O4wfr/8793Kk8rju5WHlcd3G6W6lUeW+xuZ/PXmdr/TvS7/O40hc7+8N89z/v178/hOY8g7re46rZ4yrX40//7MVuVp6J/+yDDGy0eGfPWRIb7Voc2fW/1WhzZ/bjXqtPqtDm3+3Oq3OrT5c6vf6tDmz61+p2npnVa/07T051bzO01L77RaZ1rKOtNS1pmWPnrxxWe2WmdayjrTUtaZlrLOtJR1pqVZZ1qadaalWWdamnWmpY9eQ/OZrdaZlmadaWnWmZZmnWlp1pmWVp1padWZlladaWnVmZY+einUZ7ZaZ1padaalVWdaWnWmpVVnWtp1pqVdZ1radaalXWda+ugVbZ/Zap1padeZlnadaWnXmZZ2nWnp1JmWTp1p6dSZlk6daemjFyZ+Zqt1pqVTZ1o6daalU2daOmWmpXGVmZbGVWZaGleZaWlcZaalcUWdVstMS+MqMy2Nq8y0NK4y09K46kxLrc601OpMS63OtNTqTEsfvUz4M1utMy21OtNSqzMttTrTUqszLfU601KvMy19ryXZf261zrT0vZZk/7nVOtPS91qS/edW60xLvc601OtMS6POtETv6n5wq3WmJXpL94NbjTqt1pmWvtUu73darTMtfatd3u+0Wmda+la7vN9ptc60VGeX96izy3vU2eU96uzyHnV2eY86u7xHnV3eo84u71Fnl/eos8t71NnlPers8h51dnmPOru8R51d3qPOLu9RZ5f3qLPLe9TZ5T3q7PIedXZ5jzq7vEedXd6jzi7vUWeX96izy3vU2eU96uzyHnV2eY86u7xHnV3eo84u71Fnl/eos8t71NnlPers8h51dnmPOru8R51d3qPOLu9RZ5f3qLPLe9TZ5T3q7PIedXZ5jzq7vEedXd6jzi7vUWeX96izy3vU2eU96uzyHnV2eY86u7xHnV3eo84u71Fnl/eos8s76uzyjjq7vKPOLu+os8s7rqjTaplpKers8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yjzi7vqLPLO+rs8o46u7yzzi7vrLPLO+vs8s46u7zzijqtlpmWss4u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzvr7PLOOru8s84u76yzyzu/1y7v1V9a3a9b/VbT0p9b/ehpaayX4qPNP7facu+Xv5KzXfF7q38vf3zt8kMuf7bov8qf53X5+bXLn1+7/PW1y99y+etqLz96XbHfCdm5fzV7zquQPWVa/fAd1p/YaqvTKj0lPLZVeqL4J1v980T/4TusP7FVelJ5bKv0VPPYVukJ6LGtfqdp6Z1Wv9O09MdW5/WdpqV3Wv1O09I7rX6naemdVstMS/OKOq2WmZbmVWZamleZaWleZaaledWZllqdaanVmZZanWmp1ZmWPnyH9Se2WmdaanWmpVZnWmp1pqVWZ1rqdaalXmda6nWmpV5nWvrwHdaf2GqdaanXmZZ6nWmp15mWep1padSZlkadaWnUmZZGnWnpw3dYf2KrdaalUWdaGnWmpVFnWhp1pqWoMy1FnWkp6kxLUWda+vAd1p/Yap1pKepMS1FnWoo601LUmZayzrSUdaalrDMtZZ1p6cN3WH9iq3WmpawzLWWdaSnrTEtZZ1qadaalWWdamnWmpVlnWvrwHdaf2GqdaWnWmZZmnWlp1pmWZp1padWZlladaWnVmZZWnWnpw3dYf2KrdaalVWdaWnWmpVVnWlp1pqVdZ1radaYle4f1Y1utMy3Zu7Ef22qdacneuf3YVutMS99ql/c7rdaZlr7VLu93Wq0zLX2rXd7vtFpnWqqzy3vW2eU96+zynnV2ec86u7xnnV3eq84u71Vnl/eqs8t71dnlff/f12m1zLS06uzyXnV2ea86u7xXnV3eq84u71Vnl/eqs8t71dnlvers8l51dnmvOru8V51d3qvOLu9VZ5f3qrPLe9XZ5b3q7PJedXZ5rzq7vFedXd6rzi7vVWeX96qzy3vV2eW96uzyXt9rl/fqL1fv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H+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYH+yYHxyYHxyYHxyYHxyYHxyXlc8D84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84MD84OB+cHA/GBgfjAwPxiXlc+B+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcT84OJ+cHE/GBifjAvK58T84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA8m5gcT84OJ+cHE/GBifjAxP5iYH0zMDybmBxPzg4n5wcT8YGJ+MDE/mJgfTMwPJuYHE/ODifnBxPxgYn4wMT+YmB9MzA9OzA9OzA9OzA9OzA/Oy8rnifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBifnBhfnBhfnBhfnBhfnBdVn5vDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDA/uDE/uDE/uDE/uDE/uC8rnzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBzfmBw/mBw/mBw/mBw/mB89l5fPB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/ODB/OCx/OC+LD9410Pl810Plc93PVQ+3/VQ+XzXQ+XzXQ+Vz3c9VD7f9VD5fNeD5bPlB+96sHy2/OBdD5bPlh+868Hy2fKDdz1YPlt+8K4Hy2fLD971YPls+cG7HiyfLT9414Pls+UH73qwfLb84F0Pls+WH7zrwfLZ8oN3PVg+W37wrgfLZ8sP3vVg+Wz5wbseLJ8tP3jXg+Wz5QfverB8tvzgXQ+Wz5YfvOvB8tnyg3c9WD5bfvCuB8tnyw/e9WD5bPnBux4sny0/eNeD5bPlB+96sHy2/OBdD5bPlh+868Hy2fKDdz1YPlt+8K4Hy2fLD971YPls+cG7HiyfLT9414Pls+UH73qwfLb84F0Pls+WH7zrwfLZ8oN3PVg+W37wrgfLZ8sP3vVg+Wz5wbseLJ8tP3jXg+Wz5QfverB8tvzgXQ+Wz5YfvOvB8tnyg3c9WD5bfvCux8rnhvnBhvnBhvnBhvnBdln53DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DA/2DE/2DE/2DE/2DE/2C8rnzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBzvmBwfmBwfmBwfmBwfmB8dl5fPA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA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gx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgx3zgwPzgwPzgwPzgwPzg+Oy8nlgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfjAwPxiYHwzMDwbmB+Oy8jkwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBgfjAwPxiYHwzMDwbmBwPzg4H5wcD8YGB+MDA/GJgfDMwPBuYHA/ODgfnBwPxgYH4wMD8YmB8MzA8G5gcD84OB+cHA/GBifjAxP5iYH0zMD+Zl5XNifjAxP5iYH0zMDybmBxPzg4n5wcT8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iqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnFqRnFqRnFqRnFqRnFeWFJPTWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjODWjuDSjuDSjuDSjuDSjuC4sqZdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFJdmFLdmFLdmFLdmFLdmFPeFJfXWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLWjOLW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1JJ6akm9tKReWlIvLamXltRLS+qlJfXSknppSb20pF5aUm8tqbeW1FtL6q0l9daSemtJvbWk3lpSby2pt5bUR0vqoyW1ZhSnZhSnZhSnZhSnZhSnZhSnZhSnZhSXZhSXZhSXZhSXZhTXhSX10ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi0ozi1ozi1ozi1ozi1ozivrCk3ppR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpR3JpRPJpRPJpRPJpRPJpRPBeW1EczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczikczigcziuPCjOJdkJXUd0FWUt8FWUl9F2Ql9V2QldR3QVZS3wVZSX0XZCX1XZCW1JhRvAvSkhozindBWlJjRvEuSEtqzCjeBWlJjRnFuyAtqTGjeBekJTVmFO+CtKTGjOJdkJbUmFG8C9KSGjOKd0FaUmNG8S5IS2rMKN4FaUmNGcW7IC2pMaN4F6QlNWYU74K0pMaM4l2QltSYUbwL0pIaM4p3QVpSY0bxLkhLaswo3gVpSY0ZxbsgLakxo3gXpCU1ZhTvgrSkxoziXZCW1JhRvAvSkhozindBWlJjRvEuSEtqzCjeBWlJjRnFuyAtqTGjeBekJTVmFO+CtKTGjOJdkJbUmFG8C9KSGjOKd0FaUmNG8S5IS2rMKN4FaUmNGcW7IC2pMaN4F6QlNWYU74K0pMaM4l2QltSYUbwL0pIaM4p3QVpSY0bxLkhLaswo3gVpSY0ZxbsgLKmbZhSbZhSbZhSbZhTbhSV104xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi14xi14xi14xi14xiv7Ck7ppR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR7JpR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7YI1tdGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotOMotOMotOMotOMol+wpnaaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUQyaUQyaUQyaUQyaUYwL1tRBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pJM4pJM4pJM4pJM4p5wZo6aUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUYxaUaxaEaxaEaxaEaxaEaxLlhTF80oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oFs0oNs0oNs0oNs0oNs0o9gVr6qYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaYZxaEZxaEZxaEZ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0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlG0WlGMWhGMWhGMWhGMWhGMS5YUwfNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKAbNKCbNKCbNKCbNKCbNKOYFa+qkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWkGcWiGcWiGcWiGcWiGcW6YE1dNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKNYNKPYNKPYNKPYNKPYNKPYF6ypm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUm2YUh2YUh2YUh2YUh2YU54I19dCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4tCM4sCMYl0wo7gCsZp6BWI19QrEauoViNXUKxCrqVcgVlOvQKymXoFYTb0C0ZoaZhRXIFpTw4ziCkRraphRXIFoTQ0ziisQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFcgWlPDjOIKRGtqmFFcgWhNDTOKKxCtqWFGcQWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBaI1NcworkC0poYZxRWI1tQwo7gC0ZoaZhRXIFpTw4ziCkRraphRXIFoTQ0ziisQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFcgWlPDjOIKRGtqmFFcgWhNDTOKKxCtqWFGcQWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBYI1tdCMotCMotCMotCMolywphaaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaURSaUVSaUVSaUVSaUVSaUdQL1tRKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pKM4pGM4pGM4pGM4pGM4p2wZraaEbR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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_format","notify_set_min_revertible_side_effect_counter","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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trvC02fh9ayFT2ctvJ218PmchYvt9iM9C49nLTydtfB81sLlrIWfdOWUcNKVU8JJV04JJ105JZx15YxnXTnjWVfOeNaVM5515bTdFaVn4WddOeNZV8541pUznnXljGddOdNZV8501pUznXXlTGddOW13GulZ+FlXznTWlTOddeVMZ10501lXznzWlTOfdeXMZ10581lXTts9RnoWjrtypmUrnZzuP27yvXDclVMpHHflTMtDDpcDwqpw3JVTKRx35UzLXq853W+g91m44K6cSuG4K+d94evLoeCunErhuCunUrjpylnj9bz1y8c018fGEJdnvoI8FL4++CLAdWMJkY1fiOKiy+qiy8lFl81Fl7OHLm13Enpjl/P1+fFLS6uVxHbXocO6fN2hzNdAWC/r0vMu43zbz3S++xrBzjO1Icry4HuITR6O/6g+n7p6OXX15dTV11NXP526+nbq6uczV99hJ50jq4+nrv7Ua2099VrbYXead1a/fP8yhvvXjXeOv1jE6+F1uneLn61iL8xdW8Vexbu2ir3kd20V2x90bRXbTPRsdcJ2Hl1bxbYpXVvF9jRdW8U2QF1bFT+t+nFLkx+3NPlxS5MftzT5cUvNj1tqftxS8+OWmh+31GFfotO06sctNT9uqflxS82PW2p+3NLsxy3NftzS7MctzX7c0ix+WvXjlmY/bmn245ZmNxaiBDcWogQ3FqIENxaiBDcWogTx06obC1GCGwtRAvS6mu6epUulPhz/rfoIfVHN4VZ9ju2l4z+6hb6udu8W+tLavVvoq2v3bqEvsN27hY5p3buFnmt37xZ6/ezdbYKOpt27hU6n3bt15aXSSF5qutnkqaavFr/D5oenaXUkF6W0OpKFamU5e5vqfatbpSyvkacQ6orLSGarJ5eRbFlPLiMZuI5c8khWryeXkUxhTy4j2ceeXEYymj25CLlschnJwvbk4tW/tHS93dOSfKUiblejkPLt3KufFnG7Gilc3K5GChe3q5HCxe1qpHBxO31RuLidvihc3E5fFC5upy8xLE/xRJm/cilupy8KF7d+V+Hi1u8qXNz6XYWLkMsmF7d+V+Hi1u8qXNz6XYWLD7/70epIFvb5DBZ7y96+rY5kNJVWR/KOSqsj2UGlVfHT6kimTWl1JB+mtDqStVJaHcktKa36cUvY2wz3bfVltyTTtZx6ubnyvNUU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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","pack_returns","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","notify_created_note","get_key_validation_request","unsafe_rand","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"EcdsaKAccount::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"EcdsaKAccount::constructor_parameters","fields":[{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}}]},{"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_parameters","fields":[{"name":"inner_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"EcdsaKAccount::entrypoint_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"EcdsaKAccount::entrypoint_parameters","fields":[{"name":"app_payload","type":{"kind":"struct","path":"authwit::entrypoint::app::AppPayload","fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}}]}},{"name":"fee_payload","type":{"kind":"struct","path":"authwit::entrypoint::fee::FeePayload","fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}]}},{"name":"cancellable","type":{"kind":"boolean"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"public_key","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}]}},"file_map":{"2":{"source":"use crate::cmp::Ord;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array.nr"},"5":{"source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"55":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"66":{"source":"// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaKAccount {\n    use dep::aztec::prelude::{PrivateContext, PrivateImmutable};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n        keys::getters::get_current_public_keys\n    };\n\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness\n    };\n\n    use dep::ecdsa_public_key_note::EcdsaPublicKeyNote;\n\n    #[aztec(storage)]\n    struct Storage {\n        public_key: PrivateImmutable<EcdsaPublicKeyNote>,\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(signing_pub_key_x: [u8; 32], signing_pub_key_y: [u8; 32]) {\n        let this = context.this_address();\n        let this_keys = get_current_public_keys(&mut context, this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note_with_keys(&mut context, this_keys.ovpk_m, this_keys.ivpk_m, this));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[aztec(private)]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    #[aztec(view)]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.public_key.get_note();\n\n        // Load auth witness\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let outer_hash_bytes: [u8; 32] = outer_hash.to_be_bytes();\n        let hashed_message: [u8; 32] = std::hash::sha256(outer_hash_bytes);\n        std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message)\n    }\n}","path":"/Users/yashbharti/Desktop/Engineering/core_projects/alpha-build-1/aztecWallet/src/noir_contracts/security_options/src/main.nr"},"69":{"source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        comptime {\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\")\n    },\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"consume((Field),Field)\")\n    },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\")\n    },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_reject_all(bool)\")\n    },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/authwit/src/auth.nr"},"70":{"source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr"},"71":{"source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: Field = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: Field = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS = 2;\n\n// docs:start:fee-payload-struct\nstruct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n    for i in 0..MAX_FEE_FUNCTION_CALLS {\n      fields.extend_from_array(self.function_calls[i].serialize());\n    }\n    fields.push(self.nonce);\n    fields.push(self.is_fee_payer as Field);\n    fields.storage\n  }\n}\n\nimpl Hash for FeePayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__FEE_PAYLOAD\n    )\n  }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr"},"72":{"source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u64 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u64 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u64 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\nstruct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n    for call in self.function_calls {\n      fields.extend_from_array(call.serialize());\n    }\n    fields.push(self.nonce);\n    fields.storage\n  }\n}\n\nimpl Hash for AppPayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\n    )\n  }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr"},"75":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\nstruct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier = poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/authwit/src/account.nr"},"80":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"81":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"83":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"86":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"95":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"97":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"102":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(_self: Self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        /// 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        /// the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        /// implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        /// 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime { EventSelector::from_signature(\"TestEvent(Field,Field,Field)\") }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"103":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"104":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"105":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"107":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"121":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"122":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"124":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"125":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"126":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"127":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"128":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"129":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"132":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"133":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"136":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"137":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"144":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"149":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"154":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"155":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"157":{"source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr"},"159":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"161":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"162":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"170":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"178":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note  where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr"},"179":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"218":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"262":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"273":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"294":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"296":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"297":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"298":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"300":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"304":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"305":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"307":{"source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"308":{"source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"312":{"source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"313":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"314":{"source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n","path":"/Users/yashbharti/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.53.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"325":{"source":"use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, NoteInterface, NoteGetterOptions, PrivateContext};\n\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: Field = 5;\n// ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN: Field = 5 * 32 + 64;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<ECDSA_PUBLIC_KEY_NOTE_LEN, ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN> for EcdsaPublicKeyNote {\n    // Cannot use the automatic serialization since x and y don't fit. Serialize the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = npk_m_hash\n    fn serialize_content(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n          let byte_x: Field = self.x[31 - i] as Field;\n          x = x + (byte_x * mul);\n          let byte_y: Field = self.y[31 - i] as Field;\n          y = y + (byte_y * mul);\n          mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n\n        [x, last_x, y, last_y, self.npk_m_hash]\n    }\n\n    // Cannot use the automatic deserialization for the aforementioned reasons\n    fn deserialize_content(serialized_note: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n        let mut x: [u8; 32] = [0; 32];\n        let mut y: [u8; 32] = [0; 32];\n\n        let part_x:[u8; 32] = serialized_note[0].to_be_bytes();\n        for i in 0..31 {\n            x[i] = part_x[i + 1];\n        }\n        x[31] = serialized_note[1].to_be_bytes::<32>()[31];\n\n        let part_y:[u8; 32] = serialized_note[2].to_be_bytes();\n        for i in 0..31 {\n            y[i] = part_y[i + 1];\n        }\n        y[31] = serialized_note[3].to_be_bytes::<32>()[31];\n\n        EcdsaPublicKeyNote { x, y, npk_m_hash: serialized_note[4], header: NoteHeader::empty() }\n    }\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl EcdsaPublicKeyNote {\n    pub fn new(x: [u8; 32], y: [u8; 32], npk_m_hash: Field) -> Self {\n        EcdsaPublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}","path":"/Users/yashbharti/Desktop/Engineering/core_projects/alpha-build-1/aztecWallet/src/noir_contracts/ecdsa_public_key_note/src/main.nr"}}}