{"transpiled":true,"noir_version":"0.33.0+cb20e078dd909656110d133339b2b425e6c3ebb0","name":"TokenBridge","functions":[{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_returns","directive_integer_quotient","directive_invert"]},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/zVRsU4DMQx9iXOJkxQWBjoAYkOgg14ZckKIidJKDAjEjvjefhXPOXGSfXHs9/zsTBDntxDdAxNEIh3SLfglWgT09RJRd7r7Yqy7xeBpbmYSMttNoH/D8MDr1d4KzeGq83SvL/+cSssTnNMClzXdA2dIBwdc98JengubZsutlxx1OW1MgALVQp9aJ6NeTI5ZHtUuU5kovDZfS/OabSIiNY64KZDYOz4ijbhrLlORJM85mQjNBWucByvZLo03VnSBGANZnXAnEsqTaSy0YLpkRbRUYp5RDTNzUhWuFV6D7eSd6xkMIMVX+hql+SAGNgExhVP6YBSHhaL5khuCiZ6disbK6SL5TNqHUv0nOUWHEb+zrW1wbAcNJtwO+YSArEHLObhqLfaM/PVnLIstz0jCHy2EqwEq21VVC4ceelWtFmZ2zyO+t9yC6403M9bH9fEP16JzDkUCAAA=","debug_symbols":"1Zpvb8IgEMa/C699wR3HAX6VZVnqpkuTpi7qlizG7z50pbrO4Jx/wr1R0Ifrr1B4DtK1eplO3l+f6nY2X6rxw1o18+dqVc/bWFtvRmqyqJumfn06/Fnp7QfgTr98q9ptdbmqFis11iM1bV/id2w7q5upGnPYjH7JgnGdMFjXS4HpiJZQp6ixGHq1wyNiDgidmONFDsWPIwXmAmbQQJ0StKE7UtMlPe1M6ulwqqcBfUh3aMjmmT3YJPaocchsr8IcO/on9DY03y60u11of7vQ4YLQZDjFJuMgP+ZOO+zETvvhc4r6Eo7rzReEP3Ns1XiW2pylPjpzkSDRI2E4teqw7cc+6IOxhyNqG0JSswbO96J1Nq3CseiHvWgFs7NgdieY3QtmD3LZjRbMDoLZUTC7Ecwu2FeNYF81ha+Rnnp2bwfsVPZc9X36G4s8ZL//XPW6ZzcndgUxXr9tBL1/ZhB22xMiyfBWMvzpNJhgsGUh9482/vw2tvCUJbeU2LJTFt8frllPw82xLXwZRMywl52y5NnLTlm8Dnt2nxcHQ2mJiocvZnijZec3WZ+1ZZ8b5NnLPjfIs5d9bpBnLzsnzrJz2SacZy/chLPsgvciXLgJZ9lLN+Ecu2BfZcG+yoJ9lQX7Kgv2VSfYV51YX93E2ke1qKtJM+1eX5m9t88Hb7OsPt++/4niLw==","brillig_names":["_assert_token_is_same"],"assert_messages":{"48":"Token address is not the same as seen in storage","18":"Not initialized","23":"Function _assert_token_is_same can only be called internally","58":"Array index out of bounds","70":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21UvW4UMRAe27v2rP82BQiQAFEm0kEuIHxKQZVLQoVIg6Cg4wEQBVKQKPIASCBeIC094ucFKNIhCoREkwroaOj5xs6FgLiT7Z0Zzzcz38zulIzSa2R4m2hKpnPYiFcIP8ZyODYukOU5z3dEN2+LNJaawUhmJpoO+yb12LfIXoExbcn1bQG6WNHqPtxYIA9YfkpKDZ6UH/gy0SncV0SX5IpvTp6s5wDbOQpiQ3bKl4pgyEO0AmJ0hC6ILtJUGSWPQZQxFe2xAktdoVBwE1r2ZFwQP9UBep/8hCZFMYo1ThvsJsSiovgoUyoLBn/ACD1KgpmjYNiTJDBCTmOGJYol1zTkMepcdMpyJ4uYkU0EaEDQORLxISKHZxQntF2U64syDmfNQpuizb8hi+7NQtUvVPCriHcqogPiE0Kl9xpab3DK3V734v63BDBjF2C2Jt6sUNruOtnpg1uPDtf2V97d3nyzt3f3/vK17zd33z98sXH46+XP2iyQ3MGl0508XSW79Hgde0XpaiWpqCR0JB0keSEq/SEqVcu4cRpg3dGAoIfCJY3UfmAPw0AqDx7l7ZKXeVg9rvcpOVEcFRxrK9MMEGww3qS4k6l8iwHtKWO3NBZtx6Jya7sDidIpUJ5BZndMprTnOcUG7jAXJrW2Ajz9B3ys4EtgdqmosVWGnieEywgymgY+x8D582Qd+LcyKTaatC6FwoVahyMSixnxX1GW+IjoW0TdIn6qEVsMma6M/LSpxXcmYzfC1evGFXLgAh1eAIUXXkDcDFPPTkTHHXOD9iIzex5m0oteyegxXtg1JbWKjKgaZo1rwwknI05NDvUWB/Zr1T0myBFh0hlgJE7yVcFRvyqprfZVQcYfOYn7AIeMFHND81UENGcRI6LgrfnQTI7tKq4atgGyleIA9JlR7hewhFwm9ONkPZizltmQaqiOvWTm2UtmOHbaB6iu48y+LQodOCBcYG51iihs1EQHIWdCX4/4QuDVGZ09OHvwGwTa3x5uBQAA","debug_symbols":"1dzdTioxEAfwd9lrLjoz7bT1VU5ODCoaEoJG8SQnxnc/RdldBE5XAyz/udFFx/bn0s7sF31r7mY3rw/X8+X940tz9eutWTzeTlfzx2V59fY+aW6e54vF/OF6+8eNW38h+Yh/eZou1y9fVtPnVXPlJs1seVe+l7+9ny9mzZXm98leWJa4CcwhdqGk/kCsZ9e2WjZzFx35QLBmpk2wlk62g39PGvJHmMmR30SSEz+iOhyzp6O0ezoP7WnilNv/UHyomxOFNjix412znsRcdvRX9LrpeL6m0/mazmdrmt0RTXvRtm0vkerveXSRN8HRpd1xynSM43TzhfnbjnW0/Cja/yj64Mxl8u0uZ1Iayjoauvc+u633ng5Eh5zbaHWk9b0YYmizcNlMu3tRDdujYXsybM927eIM28mwnQ3bxbDdG7YbrqtiuK568ByZfGdPYdeOPd5Td/hbNnXXPv54T66zy8BZQWmvO20k14+Z4vvAq2V8tIz/z6Gk9PgYB/AcQnvKV7a1DxeRQ2eIoZ2CUftRLO7Tk7E8wYF5CMzDYB4B83gwTwDzKJgngnnA8nMAy88Klp8VLD8rWH5WsPysYPlZwfKzjp9/SLm7laHcH7F+3smIdAFQcB1I/S6I0UDnnmLrPvwIfYQR+jjF4Ye6vg+lo6ZbjGCeBObJWJ7kwDwE5mEwj4B5xs8/9fKa8gVAtWqWHRro3FNs3QeP0IeM0Ic/RR+pG68c90t4DiP0oSP0MVj62Um9j9xf682ljy44ugPBrNwmpsLpR/nhJ7mSb5+mSSl/ueS8pie79GyWTs4ZtpNhOxu2i2G7N2wPhu1q2G63qpa7tYbthusqGa6rZLiukuG6SobrKhmuq2S4rpLhukqG6yqNXVdTaq+ScMp+j5OhOOywONxgXSElFjiRhxMFOBHalXbieAFR7co2cYITod2OIEG7H0FCcCKGEwmcyMOJApxI4URwOVvgcra/xBNa1UrrGU4kcCIPJwpwIr2AqD7XIpwowYkymugCHyoaEqE9VUsB7bFaCgIn8nCiACeCy9kBLmer4c9sk2IvbJG6ZcxC8nEPj72yRWKu4bGXthjAe/DP+ucen+rBWXw7u7NE2ftPsVfCqK5qULKVZTz2GlMDeOxFpgbw2KtM1fERuxwP4MHLcR0PXo7rePByXMejl+Mq3nKFjZYrbLRcYaPlChstV9hktsK+l1d/ps/z6c1itll/+/51ebu1HPfq79Pnb0rwPw==","brillig_names":["_call_mint_on_token"],"assert_messages":{"19":"Not initialized","120":"Nested call failed!","24":"Function _call_mint_on_token can only be called internally","168":"Array index out of bounds","143":"Index out of bounds","124":"Index out of bounds","179":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/41Za4g02Vl+61R1T01PVXVXV/fMdPW1+lJ9mZr5vl1DfahBRDe7hkTxgkhURFQwohJEBFFEVCKLUfCHYMgPEWEFTVZX0IAEgxIQWZFATIKREBJy+7HJj/xIYFlI8jzvqarpfOlvyUD1nMt7zvu813PqrYfiOuYpcf3nRB6K653hR/y94M/Hc4Z/PziVtv+M/8yPcewZ+4jB4zzCpLiPOOLh903Swu+z0r7DZPgsyZ/jRtjSiUoMCfaOpDRu+G1D3uNDD8WRqDSRjnfr8S7G29ItTTeccWvOnsWY7XE2loeO67DZM/H3EyIWSVw6PS4OTViasPd6PfKKa16xAu+jG7PbF9D20eqbfmn6pJW+shrgd9Afls4wKU1PAQ9KMyDfoRF3aIalGfY60k66Q0y6CWRzLtEyV1T59a3ICzIs5M1YMMJeIzMqzUjBpODOIUkJpj1GN2V3rJKymRoMjifQyAS9ifkOWqVJR2BlV6fo9Urpg/8vgUWrFwBxLwWmd0payNtLJx4Kh8IIvyEnfl3S5xyB0UKIOLLqo4rifq+SIDRqhAF1Emtf97hKSyftaV+ZJ+PSGQ+1P8bv+HpSOhOIfHlWysgvJT4vpdcpZXhRShoU8j6wA4sQ28S6YDgBqPFkClB/KlOCopamEGEynWHwz2XGQRUU/uLOJtPSmY4pZ0o5UxL9pSV6BCfyXYQCvN2DB7fp3i2xetPFQ+hqTODDQY/K6I2x+m9kbJUxGQEstVhKBPxd4O8Cfxf4u8DfJX7Q/4OckT4jKgab06sdrMfIiDkU1g4dMjJ69ZBXD0Ueh0a1o46E8fCYu8BFRxw6dhn8Tuh2lGYym2KGWpSpOpMq1EwhyJQ0U3anE0o8gc9OJtKejNEau9ZZPk79ucGttP5fINonYJIA1u/ARD6sPOogp/RTRKvj3or3FvrSZ6BciD7GyrE/6YgziajBL1gN1mAnDdj4NELM9NQe01kp0zl2m88Wl+IsFsC4WDBNyaJ6NE2Bx6uygI7mWDU380K+ArGoCeeYAxhiQ6HgMlOGbE7NjAx16WxeymwBhot5BoZZBoZZpgyz6qkYOqFkYAgI7sIsCqdVGnU754gD5imLg02F8sicRgNBPy2ca3BJ/TlZL6DEInsD8p79i6X+W95iWuYFdnVmVER/Dod2ljIrnD9AKM3h7JgaT2vfGDepRL0ntd7Drl97jq/dVan535WVngprdFfsrlUvbK4MBteb0mQb9DYGre5RqzQrDbPXW9k9ubJuLbkHIm6AZBj5hfMjUMyqcH4UYq4W61sx75F14fxE6fgruNIqwpDzU7LWYJT+tHDeBsppsgLlbwgW/iy8kopojWpFjBqvmhrGirdSB1u/xRVVhqypO52e0n7smfseIqM0l76u0XTWZ3KB849TU2dWRsyMiugx34xTZCrnt22mQr6Z23wTH+cb9WyNvin39/HMJpU5aweaVC5aOfCscWANoGkTQI/Z3Du2eXN8jDTXmoyC+Aat7lELIjBOWlm9MjtaicEMxuk2Z9ap1hJPOoMZobRoXDjvtf79Iv17MYI6XpNR4bwErSFlOKPIx9A/4+JgzQjK95MyIeVHSPmvcHU1Y1orIlVIE7VTqmJqyvbVjClvIdDdvRl5xtybEQluAnSX4/s0r2aEsSczQ1PMaAAcscPC+2FMjAhnRJQfF3jlVwEHh+nMJ+OFCpVh7pOSVQePb5AW3CxdlM4C8TghoWsJEb7O52TZEC7xu1RCLGnPM90zI2lG0i9ZUvjNyPpN69hvbG6zWyD1+HjmSANfpaUGo6gG/Wqt2hFVS8f0NdMQ9Dca0PMKNDTnQ7pxBtNkNI1pV+udKcbcLOHYHIowHcrGYTxLyrjGvsv1BvOxbCrgvgXuHQO3KUHDfrnGvWdNzoMlEGdL7j6pOJoVbLWcFuYH4BdgSMX4CXCbH5KsQE5R/rOMvsH0tazSF3yDzcysNJNRQWajvgHOsimdpcoKbzbZEvJmpu75nGt6yyfgt6sVf1/xg5ZI1eeB9lsNYJ49NsCLVBjloIHNW2VZmF+lDHiWipZzqsMftzq06MnLh8DrFYRulO2vcxD+tOQNYY7fXAmxpL3a6J4rkq5I+guWFHJlJxzKJmK7xQry4NnMgI+uOsiiGvQ7rFciFdAmOP25/3TFBP1bSNDmL5B2ATNdk3fOuXyLud+VbQVzbbb43U7z0slhjTEJXUu4A+Efya4h3OF3p4RY0t5sdc8NSTckfZclhTyrE/Iol2oLHC08gLYp8DExDFZRDfrd9RGy4hHCACGD1YYK+6tGt1OrmBUAb6BfP0eA5BEN9YI1FBSBMTdPOPZB2RTm7yDbhsN4tpRxj323+wPmX5JDBXxzwsEUsjng97DdA/ienAcbIM43RPyBCrHZ4UzajArzGQQIGP479t8kxP1FyQvzIcs/zRkgOwQIFYLNGSBs5mZHde5VTQcNEHCWQ+lsVVaTlybfQt7c1L0N55re9gn47WrF31f8oB1T+TzbgZbxP1hDnJV6+ucrBcqapz0VRjnUaV6RbeF2KAOeraLlnOrwK1aHFj15bfals99B6EbZm/0NCF+Vm4bwBr83Sogl7d1B9zyQ9ABSXFZvKrvkJxzK2sVucYA8eHYp8DFuBnlUgXYj6+ml5LQJ8OAUmK006cJ67tBaT49LehO9LaW3uan1Nl7GGYujjSoyVZe790uyWFoWT7hRWP2r+68qx4f+nRlT4Vo9f72aY5cHMq8S7axT3bHc70IIu3+LLAOu03V9W13Z2yq7W3R59MCb2D32K3T3pTqRK3u9fxzQpX/JQb2Ozb3B4OEGOVMVadDqHrVKs1/V94/9/f3DruT9A0rvqrnNE1pLPPs5XG2L+8eucH8OwbEs3J/n6cSj2v0YTg/3F0tnt0QMLyMO/bI9CEGZF+6vBAxjXrXfh/zs/lrpzLf1GZPfnzG5OpSeMUtVeNacMZlNWJgGhq2mL3PfMznQXe50jR7ifQTZFo6bz42+ruAgz3GNXOf6HkI0cxr9+cbomxNGX99nVu6/w7PmTS7eADYnkd8J29JtuLX6ySYvZbMDk12+xSvOdotXnO1WX3G21VO94rh/LRCga6MAin03OIzpJcCwduFkmylfZ+A+egLOeQLOF1j397Kw2p3zPQeyLinTkop/ibb4MDSMg3ie1QGeM8Dd9zcBntkAzxm3uC2tsjrAcwa4+8EmwDMbnXkd4ItDVl/T8gVJ/7MJ8OWJALc+ZLfA62OG5zAHPs2/vKBY0P9be8uS3kJNEstSQX+iAV1lwCWxwCF2B3jbIdqD5tOytyfGFmPuIeHYq7Iv3M9Btj2H8dxQxlvse3N7h/lX5K4Cvj+RcQtwKgz67t3NLYDfkvNgD8SHPRF/rUJsChzq+23h4X7bB8PXsP8+AW648KFwv275zw909wJ+Q1Vgc/rNjeqmoDpvNVzv1N3BWe5K56YJP4Q2dG/q3p5zTe/mCfjtasXfV/ygBdIbDWOg5eVGryDLDMryFpUCJWNgU2GUgxncy+Wm8N5EGfDcKFrOUYdeYXVo0ZPX/rZ0bgsI3Sh7f/sAhG+QBw3hA/w+UELCLe50zzuS3pH0jZYUch1OOJS1i93iDvLgKebAx2w2OEQ16Ddbr0RepE1QOtJXDxPEpen0kCs8lBNDxOWZ1ny8Usu0UKHU5STPlpPY7dSlpI52A3R5QEnAQmoYEL1fF6B8taxW8vD2J7j5m+Dku11p4rP7eoTb1CNYvGpxu+B+OzaDervXf1WMyRDCDSBk1Cm834NXxoX3+9BufMVK08+g0uT9Yel0hgieYRRDV38scZWqrwrveVBeJUNQPo16qveu0vFYcG2xpJvcF4jZHBqC9aiaxETqu6yrRKWTXGPs2lyX5jphz9z3TAJ0lx1dQx17faSva1xIEg9UnsGsl6DOe9FJAO0FSQgN/fNuh8UouWD7IumL00nOQfFeOb8H/yKC/6p/CfBjuSy8lx6rDfIaENXGjI4K3RiMQhYAUXuGoP2k8P4NWyX93tPS/t73vGwkwp4t6RXef6BIZxdp0baPgl0QA1Pc7QHNf0mvQoMtXtYtqOEvC2zwP3b0w83oxzj6Ea3Bu9+nvw/gkQmU2mbtt92Lu0R8ujSPyi5K++1IS/6wWRKF2PKzElZhVuFLYI0o/p665tWl3gcxwiSJu6B/RboWb0xkyh2Mo5hyi3zqRXVHw8Jp1xZOiYDNLgfDAA4XaEwQQXCBHV+TiwpB11zg9yKhhkJFwC8J6i0DFsKTEBprubXGQmqMyiWKkCjC4Lu5KqBPaf2WTEIwaYWWyX252RynCBsulnnIzx/KkuXmpEc7XktkUzeygfRoa7C8usR695K+bhLIe0l5E5WXzUsOJsgeLa0ux4ySmPh3Fr+SqGmuUNCPE5UXQSIszV8NkqiOqocytPIm9Fd+3uBWQ/hDC1YoWj/JgMOjoUWJr0KG7RslqNjERuW7ClHEh3HPSOhaQrwbt56x78Y2AfE9UwkD6jPQPeksV6xDtN5qSaHF4YlEWyUd3QKeRm8LPOBTeYZRDfptdfIYMnkQy+slr7BJVENWCw0rQfEIH0Rab7cfRJRYS2PIZFoG7wRIVEFEmndUH02cHsbcIOHY86iKt34TemDlXD/JEMOEbwD8ptH6naZSGJw4JatyON9GUxQcfB6Lo0EA6UYBVfTOunAyPoP4vaLF0ltQtP4kIH8U1Fr/hIJa688sf48ytU58YBoZ1i/10E3NVDMlOMuURf7mYxW+yAQjU/cCzjW99An47WrF31f8oAXSVE8AoKUbqDixivOPdeEk4JlAhVEO1f+/UI8fpQx4tARIHQaqww9YHVr05BWwAIiL6lmj7GCCqnnrQ49/K1JCLGmPp7onv1sEY5L+d/PF6FQlrvpqoFuMWQNGmRHO91G6hxaCLOj/qxxCRrQJPXNIYa+CDiY/JZ363c+vj2zrkmx2jL/3quwysAXOjnVVJLWgoqDz91mzhjVGfGn2dXx8X8ZyLOpr+50Lv21Y1QSw7MTu0cGFg1+AYEV8loPWDD2Ole+JfgXj17fhBN9wWt+ovoLJhJ+GHjm+67cvAKCN7HZ2K+2Wf1a0z8DC9VtF++oRQbccXh18CPKUNs5DLDj3Pb9zBWgdv8Pvzvin35079qlfPtpDv4PlPhdcgN2F77Pb0q7xff+C3XNwPy/anaccCkvGD3QRQWHRmX/G7hlY+jYR654+mJ4fIzwHQruD8uCmyuP8aJHLRbZ/YZFc+B0rV0C5ArAJKVfoh5QL/1Su0D6NXE/7oSLHgggQI7tbR7vY2o/YDcAlKNpbO3Xmtx88kuuXr1/+JpdcKwTNHwAA","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"768":"Array index out of bounds","957":"Array index out of bounds","634":"Array index out of bounds","1274":"Array index out of bounds","622":"attempt to add with overflow","1067":"Array index out of bounds","1250":"Array index out of bounds","1055":"attempt to add with overflow","793":"Array index out of bounds","781":"attempt to add with overflow","1482":"Array index out of bounds","903":"Array index out of bounds","1013":"attempt to add with overflow","483":"Array index out of bounds","1501":"attempt to add with overflow","1495":"attempt to add with overflow","788":"Index out of bounds","593":"Array index out of bounds","1355":"Array index out of bounds","965":"Array index out of bounds","1282":"attempt to add with overflow","581":"attempt to add with overflow","642":"Array index out of bounds","1075":"Array index out of bounds","752":"Array index out of bounds","1002":"Array index out of bounds","1258":"attempt to add with overflow","1319":"Array index out of bounds","161":"attempt to add with overflow","740":"attempt to add with overflow","801":"Array index out of bounds","984":"Array index out of bounds","1368":"attempt to add with overflow","978":"attempt to add with overflow","143":"Array index out of bounds","539":"attempt to add with overflow","1466":"Array index out of bounds","698":"attempt to add with overflow","375":"Array index out of bounds","1454":"attempt to add with overflow","814":"attempt to add with overflow","491":"Array index out of bounds","229":"Args length exceeds maximum","601":"Array index out of bounds","150":"Array index out of bounds","528":"Array index out of bounds","650":"Array index out of bounds","1223":"SharedImmutable already initialized","1412":"attempt to add with overflow","1534":"attempt to add with overflow","1083":"Array index out of bounds","1339":"Array index out of bounds","949":"Array index out of bounds","510":"Array index out of bounds","1327":"attempt to add with overflow","108":"attempt to add with overflow","937":"attempt to add with overflow","504":"attempt to add with overflow","760":"Array index out of bounds","687":"Array index out of bounds","669":"Array index out of bounds","1303":"attempt to add with overflow","663":"attempt to add with overflow","139":"attempt to add with overflow","1096":"attempt to add with overflow","1474":"Array index out of bounds","1401":"Array index out of bounds","1194":"Initializer address is not the contract deployer","1383":"Array index out of bounds","1188":"Initialization hash does not match","609":"Array index out of bounds","475":"Array index out of bounds","1292":"Array index out of bounds","1347":"Array index out of bounds"}},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_l1_to_l2_membership_witness","pack_arguments","enqueue_public_function_call_internal","directive_integer_quotient","directive_invert"]},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/21RPU8DMQx9ifPhpKULAx2AAYkBqbTXgZxAYqItYkAIdsT/7Z+C55xgIpJ9Zzvv+dkZIM5vIXoABoiPdEg34Em0COjTBZLudPfOWHeTwdPcyCJktExYMzEfQab9wS7u7cJl5+k+P/5yZisPcC5VOE35FjhFfnZdgEuNVZiIrie3DhKiBscqf5MlcxmYr83X0nzSrrohxRWuKiR21i3yCtfNKTtK9pyFhdBc0HNOlO66mr/z/c9BXiClHEm2RjSJDWrdZWO0pImBOrxQpIRybzyFJjZJmLNfqMQ+oBqW28kqXDa89n29cHXRAFJ8pa8xNC/BwCY5ZlnQi1EcJormizbmOOboVDTNuPBEPpv3VTnvGzlFeeFrtD1Hx3bQYNuwn3JCQNGg9YzLr1rtcfnpj1snmx6XhJ9aCVcDzNhupmph7KFX1ZmFhd3LCh9bJ2S0xpsRy+Py+ANBzWdvWwIAAA==","debug_symbols":"7ZpNbsIwEIXv4jULj+0Zj7lKVVWhhSpSFCp+KlWIu9dQHEhAZkFBHokNxPAwX17sPHuUjfqYTtafb3U7my/V+GWjmvl7tarnbWxttiM1WdRNU3++nX6s9O4FzF6//KraXXO5qhYrNdYjNW0/4nv87axupmpMYTs6kwXrD8KAvpMCuQtaZ3TqNR6GTu3NBTEFAwcxxT85Fb+OFNgbmEGDOyhBW/dAaneL094mp8M1p8FwSGdoHeaZGTCJ2WgzZMZ/YY5G96F3XdP9uvb365rv13W41DUjp8sTzJWRTdRddwonI3s3Bs7UGAKmwaqB8qMEPaaZHg95MEqMFksOYsmNWHIrltyJJUex5CSW3IslZ7HkYjPUis1QW/RdkV1HzjgkL3mGcrfxiIc0JH/0DGXdkVvIk3ubVrneHSkM2D14EArutFRwKBgcdAdue+AXNqpMaQcMcEXrKBni+LhnN7T3wzz96Plhn370/HBPP3p+4NOPnh9FLzFzyx0seYnJXSkZ2Q1Lp1hymYaNyZCXXKbJk5dcpmEdjuScFwfr0l0iFuXt8DSd1D0AllzTyZOXXNPJk4vdMWLJNZ08ecmBmyWnogM3S1504GbJiw7cLHnZgZsjF5uhJDZDSWyGktgMJbEZSmIz1AvN0G1sfVeLupo008NDWLN1+37yTNbq5+vvmyj+BQ==","brillig_names":["get_portal_address_public"],"assert_messages":{"45":"call to assert_max_bit_size","18":"Not initialized","69":"attempt to add with overflow","57":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi"}]}},"file_map":{"102":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"104":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"118":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n"},"122":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"124":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"125":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"126":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"130":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"133":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"145":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"161":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"164":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"167":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"182":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"195":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"204":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"213":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"214":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"219":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"220":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"237":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"239":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"246":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"259":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"304":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"317":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"318":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote { amount: serialized_note[0], secret_hash: serialized_note[1], header: NoteHeader::empty() }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"319":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:TokenNote\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n\n    // docs:start:compute_note_hiding_point\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n    // docs:end:compute_note_hiding_point\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness: unsafe_rand(), header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"333":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::encode_and_encrypt_event_with_keys_unconstrained\n    },\n        keys::getters::get_current_public_keys, utils::comparison::Comparator\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::{TokenNote, TokenNoteHidingPoint},\n        balance_set::BalanceSet\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote>>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, Comparator.EQ, amount).select(\n            TransparentNote::properties().secret_hash,\n            Comparator.EQ,\n            secret_hash\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is publicly available in a key registry contract under a fee_payer address. So if we have\n    ///         a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is trivial (slot\n    ///         is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.at(fee_payer).set.storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.at(user).set.storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\")\n        },\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained pub(crate) fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"346":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes:[u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes:[u8; 32] = secret_hash_for_redeeming_minted_notes.to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"57":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"64":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"67":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"69":{"path":"/home/roger/dev/code/alpha-build-1/contracts/aztec_bridge/src/main.nr","source":"contract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n    use dep::token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n     #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n}"},"70":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"72":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"81":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"87":{"path":"/home/roger/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys, constants::NULLIFIER_INDEX},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"}}}